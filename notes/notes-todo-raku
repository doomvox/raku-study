/home/doom/End/Cave/RakuStudy/Wall/raku-study/notes/notes-todo-raku
Saturday August 23, 2025   4:46 PM

I bad idea whose time has come: notes-todo_raku
A FINO stack of bits or raku-ism I want to keep track of.

===

https://www.reddit.com/r/htmx/comments/1ltbenc/harc_stack_componenting/n1pokqo/

]librasteve[S] 1 point 1 month ago 

thanks for explaining - yeah raku can be a bit different, I get that it's not for everyone and that you have to be a bit of a contrarian to want to use it

fwiw its not an either/or though, raku has both

role composition: role R { method m { say 'ho' } } class C1 does R {}; C1.new.m; # 'ho'

class inheritance: class C1 { method m { say 'yo' } } class C2 is C1 {}; C2.new.m; # 'yo'

dang I did it again!

[raku has the vast majority features of the Java / C++ OO system but with much less heavyweight syntax]

===

https://stackoverflow.com/questions/66926663/is-there-a-convenient-way-to-replicate-rs-concept-of-named-vectors-in-raku-p

Is there a convenient way to replicate R's concept of 'named vectors' in Raku, possibly using Mixins?
Asked 4 years, 3 months ago
Modified 4 years, 2 months ago
Viewed 413 times
Part of R Language Collective
===

Recent questions on StackOverflow pertaining to Mixins in Raku have piqued my interest as to whether Mixins can be applied to replicate features present in other programming languages.

For example, in the R-programming language, elements of a vector can be given a name (i.e. an attribute), which is very convenient for data analysis. For an excellent example see: "How to Name the Values in Your Vectors in R" by Andrie de Vries and Joris Meys, who illustrate this feature using R's built-in islands dataset. Below is a more prosaic example (code run in the R-REPL):

===

https://raku-advent.blog/2024/12/25/day-25-raku-2024-review/

Flattening

The .flat method optionally takes a :hammer named argument, which will deeply flatten any data structure given:

my @a = 1, [2, [3,4]];
say @a.flat;           # (1 [2 [3 4]])
say @a.flat(:hammer);  # (1 2 3 4)

One can now also use HyperWhatever (aka **) in a postcircumfix [ ] for the same semantics:

my @a = 1, [2, [3,4]];
say @a[*];   # (1 [2 [3 4]])
say @a[**];  # (1 2 3 4)

===

Saturday August 23, 2025   5:05 PM

https://stackoverflow.com/questions/79528856/how-to-make-altering-a-deep-field-more-idiomatic/79540270#79540270

 have a hash with several layers of sub-hashes, and I want to alter all the modified fields in the bottom layer.

The hash has the following structure

%sources{$lang}{$filename}{$attribute}

The code I have, which works, is

for %sources.values {
    for .pairs {
       for .value.pairs.grep({ .key eq 'modified'}) {
          .value = transform-modified( .value )
       }
    }
}

This is very ugly.

---


===

https://stackoverflow.com/questions/79550260/how-to-use-gather-take-with-race/79551766#79551766



I can parallelize execution using Hyper and it works:

$ raku -e 'race for (^8).race(batch => 1, degree => 4) {sleep rand; .say}'
0
3
5
2
1
7
4
6

But how can I add gather/take behavior to such loop?

  
Eagerness, Lazyness, and Hyper / Race

Hyper and Race basically live on the same spectrum as Eager and Lazy.

What gather/take allows you to create easily is a Lazy sequence. It will not generate values - and ideally not do any computation - until some consumer asks for more values. At the position of a take, execution of your code can be paused. This is what "coroutines", or "cooperative parallelism" are about (this is a bit of a simplification, but correct enough).

Eager is one step away from Lazy. Evaluating a lazy sequence eagerly will ask for all values right away, until the sequence is exhausted.

Even further away is Hyper. Hypering a part of (or the entirety of) your pipeline distributes work across multiple threads. Values are calculated "as fast as possible". You do not need to ask for more values in order for more computation to happen.

You are already using the degree and batch parameters to ensure that your very small input sequence of just 8 values (^8) even launches parallel workers in the first place.

Race is one more, albeit little, step further away from lazy. You want your values to not just be calculated fast, you specify that you wouldn't even mind if the results come out in a different order, as long as a value that was calculated is available quickly. Hyper on the other hand gives everything coming into the pipeline a number, and corresponding results coming out are ordered by this number.

  ...


"This part about control exceptions were enlightening and gives
  straightforward explanation why gather/take and race cannot coexist
  without extra work in the language itself""

---

Marton keeps rolling on the subject:

https://github.com/doomvox/raku-study/discussions/17

===


https://github.com/doomvox/raku-study/tree/main/bin/2025jul13





===
